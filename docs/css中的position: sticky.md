# css中的position: sticky

## 介绍

`position: sticky` 是 `css3` 中新增的一个定位属性，`sticky` 有粘性的意思，所以这个定位属性被称为粘性定位。对于这个属性 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 的解释：**粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。**

## 示例

基于粘性定位属性的表现，我们最常见的使用是实现导航栏或者标题栏的固定效果，示例和核心代码如下。

![nav-sticky-demo-cut-min](https://user-images.githubusercontent.com/27217394/216280333-fa359cd6-7a7b-45b6-96eb-75992f10213c.gif)

```html
<body>
  <div class="box">
    <h1>TITLE</h1>
    CONTENT
  </div>
</body>
```

```css
/* h1 style */
position: sticky;
top: 0;
```

观察上图页面滚动过程，标题随着页面一起向上滚动，当标题滚动至视口顶部时，立刻粘在屏幕上，表现出固定定位的特性，但当我们继续做滚动操作，标题又随着页面向上直至消失。

所谓的粘性元素，**何时有粘性，何时失去粘性，即两个阈值在哪里，**下面基于这个问题讨论其表现背后遵循的原理。



## 规则与原理

#### 滚动框（scrolling box）

搞明白上面的问题需要先弄清楚一点，阈值是相对谁计算的，就像我们要知道一个元素的位置和大小，需要先知道它的包含块 [Containing Block](https://www.w3.org/TR/2016/WD-css-position-3-20160517/#containing-block) 是谁。对于这个问题，`w3c` 在对[粘性定位](https://www.w3.org/TR/2016/WD-css-position-3-20160517/#sticky-pos)描述的第一句就说到：

> A stickily positioned box is positioned similarly to a [relatively positioned](https://www.w3.org/TR/2016/WD-css-position-3-20160517/#relative-position) box, but the offset is computed with reference to the nearest ancestor with a scrolling box, or the viewport if no ancestor has a scrolling box.
>
> 粘性定位元素与相对定位元素类似，但偏移量是参照最近的具有**滚动框** `(scrolling box)` 的祖先计算的，如果没有祖先具有滚动框，则参照视口计算。

现在了解了阈值是相对滚动框计算的，不过关于滚动框的判定，官方并没有给出更进一步的解释，我们暂且认为是有滚动条能被鼠标来回滚的元素。

#### 与相对定位相似之处

本篇开头提到了粘性定位元素与相对定位元素有相似之处，其实单看表现感觉与相对定位并没有什么联系，不过看了文档描述后，有以下总结：

- 二者皆保留在[普通流](https://swordair.com/css-positioning-schemes-normal-flow/)中的空间
- 都会为后代绝对定位元素创建一个包含块
- 他们的包含块相同（最近的块级祖先元素或行内祖先元素的内容区域 `content-box` ）
- 如果没有设置 `top/right/left/bottom` 等属性，其表现与相对定位相同

#### 粘性约束矩形（sticky-constraint rectangle）

前置问题解决以后，再来看问题本身：阈值的具体计算。

文档中提到了一个**粘性约束矩形**的概念，它是一个用于约束粘性定位的元素位置的矩形。也就是说，粘性元素只能在这个矩形之内活动，弄明白这个矩形是什么，就能解答我们的问题。

**粘性约束矩形：**

- 依据粘性元素的 `left`、`right`、`top` 和 `bottom` 属性值对滚动框进行“裁切”后形成的矩形区域和粘性元素的 `Containing Block` 矩形区域的重合部分，这个重合区域就是粘性约束矩形。

**如何约束：**

- 约束矩形会随着滚动框的滚动而发生变化，当这个约束矩形开始不再能容纳粘性元素的原有位置时，粘性元素会向下移动，表现出固定定位元素的特性，固定在滚动框相关偏移位置的边缘。
- 随着约束矩形的变化，当粘性元素自身大小即将超过约束矩形的范围时，将被限制做任何方向的移动，这时元素将失去固定定位表现，会随着包含块一起滚走。

简单分为**三个过程**，这里以粘性元素 `sticky` 设置 `top: 20px` 为例：

1. 刚开始滚动，包含块的区域即约束矩形的区域，`sticky` 会在包含块内正常躺平；
2. 继续滚，包含块顶部滚动到 `20px` 的偏移线时，包含块开始冲出这条线，约束矩形开始缩圈，`sticky` 固定在偏移线上；
3. 继续滚，滚到 `sticky` 大小刚好被约束矩形所容纳后，再滚，`sticky` 开始冲出包围圈，约束（容纳）不了了，再见。



## 几点注意

1. 如果粘性元素的初始位置在约束矩形的上面，那么粘性元素将向下移动，直到完全包含在粘性约束矩形中。也就是图2情况，页面初始渲染时就会把粘性元素移到圈里。
2. 设置的定位值有冲突时， `top` 优先级大于 `bottom`，`left` 大于 `right`。
3. 属于同一个父元素的粘性元素，如果设置的定位值相同，那么他们会重叠在一起。



## 粘性无效

我们在使用粘性定位时，假如没有出现我们想要的效果，这时候要注意是不是有以下的情况：

1. **在滚动框之内，有任何一个祖先元素的 `overflow` 属性设置为除 `visible` 以外的值**，因为设置这些值会改变[滚动容器](https://www.w3.org/TR/css-overflow-3/#valdef-overflow-hidden)（这里的滚动容器就是上面提到的 scrolling box），滚动容器的改变影响到约束矩形的计算，自然会乱套。
   - 这里需要注意的是，设置了 `overflow: hidden` 的元素只是被 `UA` 禁止滚动了，它仍然是一个滚动容器，我们仍然可以以编程方式设置元素的 `scrollTop/scrollLeft` 来滚动它。
   - 顺便提一下，设置 `overflow: clip` 是完全没影响的，它确实不是滚动容器，但鉴于目前各大浏览器对他的支持度为 0，所以不考虑。
2. **在计算粘性元素在约束矩形中的容纳度时，粘性元素的边距 `margin` 也会被计算进去。**这个特性还蛮奇怪的，但是需要格外注意，很容易被忽略导致粘性无效。

## 浏览器支持度

撇开 IE 浏览器来看，其他现代浏览器对这一属性的支持度还是比较友好的，在 Safari 上我们需要添加 `-webkit` 前缀。现在我们在小程序的吸顶效果基本都是使用了这一属性，之前类似吸顶效果的实现都依赖于监听滚动条，因此大大减少了代码量，也免去了监听所带来的性能问题。
