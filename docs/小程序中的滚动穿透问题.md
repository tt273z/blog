## 背景

这个问题源于小程序的一个bug，在小程序中有各种各样的弹出层，而当我们在这个弹出层或者遮罩层上触发滚动事件后，这个事件会穿透到底部的 `page` 层，从而引起底部页面的滚动，这就是滚动穿透。

这个问题对我们页面的功能其实没多大影响，但是从体验上讲，是有点不太好的，所以我们就来看下怎么干掉它。

## 解决方案

按弹出层中内容是否需要滚动分为两种情况。

- 弹出层无滚动

  这种情况的处理比较简单，在弹出层的根节点阻止 `touchmove` 事件冒泡，一行代码就解决，不管怎么滑页面都不会动。另外，在 `Taro` 框架中阻止事件冒泡的方式跟原生小程序不同。

  ```tsx
  // Taro
  <View className="pop" onTouchMove={e => e.stopPropagation()} />
  // wx
  <View className="pop" catchtouchmove />
  ```

- 弹出层有滚动

  处理这种情况一般的思路是，在弹窗出现时，动态给页面根节点添加以下样式，使底部页面固定高度为视口高度不可滚动，这样使得底部的滚动事件无任何表现，从而“阻止”了滚动穿透。

  ```css
  position: fixed;
  height: 100vh;
  overflow: hidden;
  ```

  但这样写会有一个问题，如果页面本身是可滚动的（高度超出一屏），那我们设置的以上样式会让页面自动回到顶部，所以这种方法只适用于内容只有一屏的页面。

  对于高度超出一屏的情况，我们使用 `<scroll-view>` 容器来处理，这个容器有个 `scroll-y` 属性，我们利用这个属性来控制容器的纵向滚动。

  ```tsx
  <ScrollView scrollY={!showing}>
    /* content */
    {showing && <Pop />}
  </ScrollView>
  ```

  底部页面根节点替换为 `<scroll-view>` ，当弹出层出现时，`scroll-y` 设置为 `false` 禁止纵向滚动，弹出层关闭恢复滚动，这个方案看起来还可以，没什么副作用，但需要注意两个点：

  -  `<scroll-view>` 需要设置初始高度，一般情况设置一屏高度即可。
  - 一旦根节点被替换，一些页面专属的事件处理函数也就失效了，比如 `onPullDownRefresh`、`onReachBottom` 等，如果需要这些事件，需要在 `scroll-view` 中开启自定义下拉刷新。

